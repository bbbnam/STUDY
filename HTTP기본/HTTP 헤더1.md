### HTTP 헤더1

#### 개요
- 용도 : http 전송에 필요한 모든 부가정보
- 표준헤더가 너무 많음
- 필요시 임의의 헤더 필드 추가 가능
- 메시지 본문은 엔티티 본문을 전달하는데 사용
- 메시지 본문 안에 엔티티 본문을 담아서 전달
- `엔티티 헤더`는 `엔티티 본문`의 데이터를 해석할 수 있는 정보 제공
- RFC7230(최신스펙) 에서 `엔티티` -> `표현` 으로 변경

#### 표현
- 일종의 형태(?) 라고 이해하면 될 거 같다.
- html 로 `표현` 혹은 json으로 `표현` 이라고 한다.
> - Content-type : 표현 데이터의 형식 설명 (미디어타입, 문자인코딩)
> - Content-Encoding : 표현 데이터 인코딩 (표현데이터를 `압축`하기 위해 사용)
> - Content-Language : 표현 데이터의 자연 언어 (ex > ko, en, en-US)
> - Content-Length : 표현 데이터의 길이 (바이트 단위)
     ** 전송 코딩을 사용하면 `Content-Length` 를 사용하면 안됨

#### 콘텐츠 협상(요청시에만 사용)
- 클라이언트가 선호하는 표현 요청
> - Accept : 클라이언트가 선호하는 미디어 타입 전달
> - Accept-Charset : 클라이언트가 선호하는 문자 인코딩
> - Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
> - Accept-Language : 클라이언트가 선호하는 자연 언어

- 협상과 우선순위
> - 생략하면 1
> - 0~1, 숫자가 클 수록 높은 순위를 가진다.
> - ex> ko;q=0.9,en-Us;q=0.8,en;q=0.7
> - 구체적인 것이 우선(풀어서 쓴 내용이 /* 등으로 작성한 것보다 우선한다.)

#### 전송방식
> - 단순 전송 : Content-Length 를 알 때 
> - 압축 전송 : gzip 등으로 압축해서 전송 -> `Content-Encoding` 값이 추가가 되야 함
> - 분할 전송 : Transfer-Encoding 값을 설정 -> 큰 용량을 나눠서 전송  Content-Length를 넣으면 안됨!! (길이가 예상이 안됨)
> - 범위 전송 : 이미 받은 부분 제외하고 범위 지정해서 전송 요청

#### 일반정보
- From[요청] : 유저 에이전트의 이메일 정보 (일반적으로 잘 사용 x)
- Referer[요청] : 이전 웹 페이지 주소 (유입 경로 분석 가능)
- User-Agent[요청] : 유저 에이전트 애플리케이션 정보 (웹 브라우져 정보)
- Server[응답] : 요청을 처리하는 Orgin 서버의 소프트웨어 정보 (최종 응답지에서(중간 프록시 서버 제외) 응답해주는 서버)
- Date[응답] : 메시지가 발생한 날짜와 시간

#### 특별한 정보
- Host[요청] : 요청한 호스트 정보(도메인) - 필수값
- Location[응답] : 페이지 리다이렉션 
- Allow[응답] : 허용 가능한 HTTP 메서드 - 서버에서 잘 구현되어 있지는 않음(그냥 알아둘것)
- Retry-After[응답] : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간 - 실제 사용하기 쉽지 않음

#### 인증
- Authorization : 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의

#### 쿠키
- Set-Cookie : 서버 -> 클라이언트로 쿠키 전달(응답)
- Cookie : 클라이언트가 서버에서 받은 쿠키 저장, HTTP 요청시 서버로 전달
- 모든 요청에 (동일 서버인 경우) 쿠키 정보 자동 포함
