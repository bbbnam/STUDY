### HTTP 헤더2
#### 캐시 기본 동작
- 캐시 가 없을 때 
> - 요청시마다 해당 데이터를 다운로드 받음.
> - 브라우져 로딩 속도가 느리다

- 캐시가 있을때
> - cache-control 설정 (캐시가 유효한 시간)
> - 캐시가 유효한 시간 동안은 캐시 데이터를 보여줌(데이터 다운로드 안함)
> - 브라우져 로딩 속도가 빠르다
> - 캐시 유효 시간 지나면 다시 다운로드 받음

#### 검증 헤더와 조건부 요청1
- 캐시 유효시간 초과시 다시 데이터를 다운로드 해야하는 문제 발생
- 클라이언트와 서버의 데이터가 같다는 사실을 확인할 수 있다면, 다시 다운 받을 필요 없음
- 검증 헤더 원리
> - If-modified-since 라는 검증헤더 추가 후 서버로 요청
> - 서버는 Last-Modified(최종수정일) 라는 응답 헤더 리턴
> - 서버 : 304 Not Modified 라는 응답 & Last-Modified(최종수정일) 라는 응답 헤더 리턴 / HTTP Body 부분이 없음.
> - 클라이언트 측에서 보낸 수정시간과 서버측의 수정시간이 동일하면(304 응답) 데이터 다운 X, 캐시로 처리

#### 검증 헤더와 조건부 요청2
-  If-modified-since , Last-Modified 단점
> - 1초 미만 단위로 캐시 조정 불가
> - 날짜 기반 로직
> - 데이터를 수정했다가 원복할 경우 -> 날짜는 변경되어서 데이터 새로 다운받지만 실제 변경은 없을 때 불필요
- If-None-Match, ETag
> - 캐시용 데이터에 임의의 고유한 버전 이름을 다는 것
- ETag 가 같으면 캐시, 다르면 다시받기
- 캐시 제어 로직을 서버에서 완전히 관리

#### 캐시와 조건부 요청 헤더
- 캐시 지시어 (Cache-Control)
> - max-age : 캐시 유효시간 (초단위)
> - no-cache : 데이터는 캐시해서 써도 되나, 원(origin) 서버에 `검증`을 필수로 하고 사용해라 라는 의미
> - no-store : 민감한 데이터가 있으니, 저장하면 안됨(메모리 상에서 사용 후 최대한 빨리 삭제)
- 캐시제어[하위호환] (Pragma)
> - Pragma : no-cache : no-cache 처럼 사용 되나 HTTP 1.0 하위 호환으로 지금은 잘 안씀
- 캐시 만료일 지정[하위호환] (Expires)
> - 캐시 만료일을 정확한 날짜로 지정
> - 지금은 Cache-Control : max-age 권장
> - Cache-Control : max-age 과 같이 사용시 Expires는 무시됨